name: Update Release Branches

on:
  pull_request:
    types: [closed]
    branches:
      - master
      - main
  workflow_call:
    inputs:
      base_branch:
        description: 'Base branch to update release branches from (e.g., main)'
        required: true
        type: string
      merged_pr_number:
        description: 'Merged PR number (optional, for summary)'
        required: false
        type: number

jobs:
  update-release-branches:
    # Only run if the PR was merged (not just closed)
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Resolve inputs
        id: resolve
        env:
          INPUT_BASE_BRANCH: ${{ inputs.base_branch }}
          EVENT_BASE_BRANCH: ${{ github.event.pull_request.base.ref }}
          INPUT_PR_NUMBER: ${{ inputs.merged_pr_number }}
          EVENT_PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          base="${INPUT_BASE_BRANCH:-$EVENT_BASE_BRANCH}"
          echo "base=$base" >> $GITHUB_OUTPUT
          pr="${INPUT_PR_NUMBER:-$EVENT_PR_NUMBER}"
          echo "pr=$pr" >> $GITHUB_OUTPUT

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get all release branches with open PRs
        id: get-prs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BASE_BRANCH: ${{ steps.resolve.outputs.base }}
        run: |
          echo "Fetching all open and draft pull requests..."

          prs_to_master=""
          release_branches_with_prs=""

          # Collect PRs targeting the base branch (OPEN or draft)
          set +e
          tmp=$(gh pr list --state all --json number,headRefName,baseRefName,isDraft,state --jq ".[] | select(.state == \"OPEN\" or .isDraft == true) | select(.baseRefName == \"$BASE_BRANCH\") | .headRefName")
          status=$?
          set -e
          if [ $status -eq 0 ]; then
            prs_to_master="$tmp"
          else
            prs_to_master=""
          fi

          # Collect release branches that have OPEN or draft PRs
          set +e
          tmp=$(gh pr list --state all --json number,headRefName,baseRefName,isDraft,state --jq ".[] | select(.state == \"OPEN\" or .isDraft == true) | select(.baseRefName | test(\"^release[/-]\") or test(\"^[0-9]+\\\\.[0-9]+(\\\\.[0-9]+)?$\")) | .baseRefName")
          status=$?
          set -e
          if [ $status -eq 0 ]; then
            release_branches_with_prs="$tmp"
          else
            release_branches_with_prs=""
          fi

          # Merge, dedupe, and filter non-empty lines without failing when empty
          all_branches=$(printf "%s\n%s\n" "$prs_to_master" "$release_branches_with_prs" | awk 'NF' | sort -u)

          if [ -z "$all_branches" ]; then
            echo "No release branches with open or draft PRs found"
            echo "branches=" >> $GITHUB_OUTPUT
          else
            echo "Found release branches to update:"
            echo "$all_branches"
            branches=$(echo "$all_branches" | tr '\n' ',' | sed 's/,$//')
            echo "branches=$branches" >> $GITHUB_OUTPUT
          fi

      - name: No release branches found, skipping update
        if: steps.get-prs.outputs.branches == ''
        run: |
          echo "No release branches found. Skipping update process. Returning true."
          echo "::notice::No release branches found. Skipping update process."
          exit 0

      - name: Update release branches with master
        if: steps.get-prs.outputs.branches != ''
        env:
          BRANCHES: ${{ steps.get-prs.outputs.branches }}
          BASE_BRANCH: ${{ steps.resolve.outputs.base }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Split branches by comma
          IFS=',' read -ra BRANCH_ARRAY <<< "$BRANCHES"

          echo "Updating release branches with $BASE_BRANCH..."

          for branch in "${BRANCH_ARRAY[@]}"; do
            # Skip if branch is the base branch itself
            if [ "$branch" = "$BASE_BRANCH" ]; then
              echo "Skipping $branch (base branch)"
              continue
            fi

            # Check if branch matches release branch pattern (common patterns: release/*, release-*, or version branches like 1.2 or 1.2.3)
            if [[ "$branch" =~ ^release[/-] ]] || [[ "$branch" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
              echo "Processing release branch: $branch"

              # Fetch and checkout the branch
              if git fetch origin "$branch" && git checkout "$branch"; then
                echo "Checked out $branch"

                # Try to merge base branch into the release branch
                if git merge "origin/$BASE_BRANCH" --no-edit; then
                  echo "Successfully merged $BASE_BRANCH into $branch"

                  # Push the changes
                  if git push origin "$branch"; then
                    echo "Successfully pushed updates to $branch"
                  else
                    echo "Failed to push updates to $branch"
                  fi
                else
                  echo "Merge conflict detected in $branch - manual resolution required"
                  # List conflicting files and add to summary
                  conflict_files=$(git diff --name-only --diff-filter=U || true)
                  if [ -n "$conflict_files" ]; then
                    echo "Conflicting files in $branch:" >> $GITHUB_STEP_SUMMARY
                    echo "$conflict_files" | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY
                  fi
                  # Abort merge to clean working tree state
                  git merge --abort || true
                  echo "Branch $branch requires manual merge resolution" >> $GITHUB_STEP_SUMMARY
                fi
              else
                echo "Failed to checkout branch $branch"
              fi
            else
              echo "Skipping non-release branch: $branch"
            fi
          done

      - name: Check for conflicting PRs and notify authors
        if: steps.get-prs.outputs.branches != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCHES: ${{ steps.get-prs.outputs.branches }}
        run: |
          # Split branches by comma
          IFS=',' read -ra BRANCH_ARRAY <<< "$BRANCHES"

          echo "Checking for PRs with merge conflicts..."

          for branch in "${BRANCH_ARRAY[@]}"; do
            # Check if branch matches release branch pattern
            if [[ "$branch" =~ ^release[/-] ]] || [[ "$branch" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
              # Get all open PRs targeting this release branch
              set +e
              prs=$(gh pr list --base "$branch" --state open --json number,author,headRefName,mergeable 2>&1)
              pr_list_status=$?
              set -e
              
              if [ $pr_list_status -ne 0 ]; then
                echo "âš ï¸ Failed to fetch PRs for branch $branch: $prs"
                continue
              fi
              
              # Use process substitution to avoid subshell and preserve step summary updates
              while IFS= read -r pr; do
                pr_number=$(echo "$pr" | jq -r '.number')
                pr_author=$(echo "$pr" | jq -r '.author.login')
                pr_branch=$(echo "$pr" | jq -r '.headRefName')
                mergeable=$(echo "$pr" | jq -r '.mergeable')
                
                # Check for CONFLICTING, UNKNOWN, or null (GitHub may not have calculated status yet)
                if [ "$mergeable" = "CONFLICTING" ] || [ "$mergeable" = "UNKNOWN" ] || [ "$mergeable" = "null" ]; then
                  echo "âš ï¸ PR #$pr_number ($pr_branch â†’ $branch) mergeable status: $mergeable"
                  
                  # Clean git state before checking this PR
                  git reset --hard HEAD >/dev/null 2>&1 || true
                  git clean -fd >/dev/null 2>&1 || true
                  git merge --abort >/dev/null 2>&1 || true
                  
                  # Check if we've already notified about conflicts (using unique marker)
                  set +e
                  existing_comment=$(gh pr view "$pr_number" --json comments --jq '.comments[] | select(.author.login == "github-actions[bot]" and (.body | contains("<!-- conflict-notification -->"))) | .id' 2>&1 | head -n 1)
                  comment_check_status=$?
                  set -e
                  
                  if [ $comment_check_status -ne 0 ]; then
                    echo "âš ï¸ Failed to check existing comments for PR #$pr_number, skipping to avoid duplicates"
                    continue
                  fi
                  
                  if [ -z "$existing_comment" ]; then
                    # Attempt to identify conflicting files by merging PR into the release branch locally (no commit)
                    set +e
                    git fetch origin "$branch" "$pr_branch" >/dev/null 2>&1
                    fetch_status=$?
                    set -e
                    
                    if [ $fetch_status -ne 0 ]; then
                      echo "âš ï¸ Failed to fetch branches for PR #$pr_number"
                      continue
                    fi
                    
                    set +e
                    git checkout "$branch" >/dev/null 2>&1 && git reset --hard "origin/$branch" >/dev/null 2>&1
                    git merge --no-commit --no-ff "origin/$pr_branch" >/dev/null 2>&1
                    merge_status=$?
                    conflict_list=""
                    if [ $merge_status -ne 0 ]; then
                      files=$(git diff --name-only --diff-filter=U 2>/dev/null | head -n 20)
                      if [ -n "$files" ]; then
                        conflict_list=$(echo "$files" | sed 's/^/- /')
                      fi
                      git merge --abort >/dev/null 2>&1 || true
                    else
                      # No conflict detected in local attempt; abort any pending merge state
                      git merge --abort >/dev/null 2>&1 || true
                    fi
                    set -e

                    # Only post comment if we actually detected a conflict (not just UNKNOWN status without real conflict)
                    if [ $merge_status -ne 0 ] || [ "$mergeable" = "CONFLICTING" ]; then
                      # Comment on the PR including conflicting files if detected
                      if [ -n "$conflict_list" ]; then
                        comment_body=$(printf '<!-- conflict-notification -->\nðŸš¨ **Merge Conflict Detected**\n\nThis PR now has conflicts with the base branch `%s`.\n\nThe release branch was recently updated. Please resolve the conflicts to proceed with merging.\n\n**Conflicting files (top 20):**\n%s\n\n**Steps to resolve:**\n1. Pull the latest changes from `%s`\n2. Merge `%s` into your feature branch `%s`\n3. Resolve any conflicts\n4. Push the changes\n\ncc @%s' "$branch" "$conflict_list" "$branch" "$branch" "$pr_branch" "$pr_author")
                      else
                        comment_body=$(printf '<!-- conflict-notification -->\nðŸš¨ **Merge Conflict Detected**\n\nThis PR now has conflicts with the base branch `%s`.\n\nThe release branch was recently updated. Please resolve the conflicts to proceed with merging.\n\n**Steps to resolve:**\n1. Pull the latest changes from `%s`\n2. Merge `%s` into your feature branch `%s`\n3. Resolve any conflicts\n4. Push the changes\n\ncc @%s' "$branch" "$branch" "$branch" "$pr_branch" "$pr_author")
                      fi
                      
                      set +e
                      echo "$comment_body" | gh pr comment "$pr_number" --body-file - 2>&1
                      comment_status=$?
                      set -e
                      
                      if [ $comment_status -eq 0 ]; then
                        echo "âœ… Notified @$pr_author about conflicts in PR #$pr_number" >> $GITHUB_STEP_SUMMARY
                      else
                        echo "âš ï¸ Failed to comment on PR #$pr_number (author: @$pr_author)" >> $GITHUB_STEP_SUMMARY
                      fi
                    else
                      echo "â„¹ï¸ PR #$pr_number has UNKNOWN mergeable status but no actual conflicts detected" >> $GITHUB_STEP_SUMMARY
                    fi
                  else
                    echo "â„¹ï¸ Conflict notification already exists for PR #$pr_number, skipping duplicate comment" >> $GITHUB_STEP_SUMMARY
                  fi
                fi
              done < <(echo "$prs" | jq -c '.[]')
            fi
          done

      - name: Summary
        if: always()
        env:
          BASE_BRANCH: ${{ steps.resolve.outputs.base }}
          MERGED_PR_NUMBER: ${{ steps.resolve.outputs.pr }}
        run: |
          echo "## Release Branch Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "Base branch: $BASE_BRANCH" >> $GITHUB_STEP_SUMMARY
          if [ -n "$MERGED_PR_NUMBER" ]; then
            echo "Merged PR: #$MERGED_PR_NUMBER" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -z "${{ steps.get-prs.outputs.branches }}" ]; then
            echo "No release branches with open PRs found to update." >> $GITHUB_STEP_SUMMARY
          else
            echo "Processed branches: ${{ steps.get-prs.outputs.branches }}" >> $GITHUB_STEP_SUMMARY
          fi